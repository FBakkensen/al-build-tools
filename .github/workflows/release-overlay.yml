# ==============================================================================
# Repository Safety Warning
# This workflow performs overlay releases, triggered manually or automatically
# on PR merges to main. Execute only from trusted automation contexts; avoid
# running release scripts inside local source clones or invoking
# bootstrap/install.ps1 within this repo.
# ==============================================================================

name: Overlay Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (semantic version, e.g., 1.2.3)'
        required: false
      summary:
        description: 'Maintainer-provided summary for release notes'
        required: false
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: write

jobs:
  release:
    name: Overlay release
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event.pull_request.merged == true
    env:
      GITHUB_TOKEN: ${{ github.token }}
      GH_TOKEN: ${{ github.token }}
      REQUESTED_VERSION: ${{ github.event.inputs.version }}
      MAINTAINER_SUMMARY: ${{ github.event.inputs.summary || github.event.pull_request.title }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Capture workflow start time
        id: timing_start
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          $now = [System.DateTimeOffset]::UtcNow
          Set-ActionOutput -Name 'started_at_iso' -Value $now.ToString('o')
          Set-ActionOutput -Name 'started_at_ms' -Value ([string]$now.ToUnixTimeMilliseconds())
          Write-Host "::notice::Overlay release started at $($now.ToString('o'))."

      - name: Resolve release version
        id: version
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Write-DebugBlock {
            param(
              [Parameter(Mandatory = $true)][string]$Title,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            Write-Host "::debug::$Title=$Value"
          }

          function Emit-StepError {
            param(
              [string]$Message,
              [System.Management.Automation.ErrorRecord]$ErrorRecord
            )

            $formattedRecord = $null
            if ($ErrorRecord) {
              $formattedRecord = ($ErrorRecord | Format-List * -Force | Out-String).Trim()
            }

            if ($Message) {
              Write-Host "::error::Message=$Message"
            }

            if ($ErrorRecord) {
              Write-Host "::error::Exception=$($ErrorRecord.Exception.GetType().FullName)"
              Write-Host "::error::ExceptionMessage=$($ErrorRecord.Exception.Message)"

              if ($ErrorRecord.ScriptStackTrace) {
                Write-Host "::error::Stack=$($ErrorRecord.ScriptStackTrace)"
              }
            }

            if ($formattedRecord) {
              $formattedRecord.Split([Environment]::NewLine) | ForEach-Object {
                if (-not [string]::IsNullOrWhiteSpace($_)) {
                  Write-Host "::error::Record=$_"
                }
              }
            }

            if ($ErrorRecord) {
              throw $ErrorRecord
            }

            throw
          }

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          function ConvertTo-ReleaseVersion {
            [CmdletBinding()]
            param(
              [Parameter(Mandatory = $true)]
              [string]$Version
            )

            $trimmed = $Version.Trim()
            if ([string]::IsNullOrWhiteSpace($trimmed)) {
              throw 'ERROR: VersionHelper - Version value is required.'
            }

            $match = [Regex]::Match($trimmed, '^v(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*)$')
            if (-not $match.Success) {
              throw "Version '$Version' is not a valid semantic version with leading 'v' (e.g. v1.2.3)."
            }

            $major = [int]$match.Groups['major'].Value
            $minor = [int]$match.Groups['minor'].Value
            $patch = [int]$match.Groups['patch'].Value

            return [PSCustomObject]@{
              RawInput  = $Version
              Normalized = "v{0}.{1}.{2}" -f $major, $minor, $patch
              Major = $major
              Minor = $minor
              Patch = $patch
              TagName = "v{0}.{1}.{2}" -f $major, $minor, $patch
            }
          }

          function Get-VersionTags {
            [CmdletBinding()]
            param(
              [Parameter(Mandatory = $true)]
              [string]$RepositoryRoot
            )

            $gitArgs = @('-C', $RepositoryRoot, 'tag', '--list', 'v*')
            $result = & git @gitArgs
            if ($LASTEXITCODE -ne 0) {
              throw "Failed to enumerate git tags from $RepositoryRoot."
            }

            if ($null -eq $result) { return @() }

            $tags = @()
            foreach ($line in $result) {
              if (-not [string]::IsNullOrWhiteSpace($line)) {
                $tags += $line.Trim()
              }
            }
            return $tags
          }

          function Get-LatestReleaseVersion {
            [CmdletBinding()]
            param(
              [Parameter(Mandatory = $true)]
              [string]$RepositoryRoot
            )

            $tags = @(Get-VersionTags -RepositoryRoot $RepositoryRoot)
            if ($tags.Count -eq 0) { return $null }

            $parsed = @()
            foreach ($tag in $tags) {
              try {
                $version = ConvertTo-ReleaseVersion -Version $tag
                $parsed += [PSCustomObject]@{
                  RawTag = $tag
                  Version = $version
                }
              } catch {
                continue
              }
            }

            if ($parsed.Count -eq 0) { return $null }

            $sorted = $parsed | Sort-Object -Property @{ Expression = { $_.Version.Major }; Descending = $true }, @{ Expression = { $_.Version.Minor }; Descending = $true }, @{ Expression = { $_.Version.Patch }; Descending = $true }
            return $sorted[0]
          }

          try {
            Write-Host "REQUESTED_VERSION=$($env:REQUESTED_VERSION)"

            $versionInput = $env:REQUESTED_VERSION
            if ([string]::IsNullOrWhiteSpace($versionInput)) {
              # Auto-generate next minor version
              $latestInfo = Get-LatestReleaseVersion -RepositoryRoot (Get-Location)
              if ($latestInfo) {
                $nextMinor = $latestInfo.Version.Minor + 1
                $versionInput = "v{0}.{1}.0" -f $latestInfo.Version.Major, $nextMinor
                Write-Host "Auto-generated version: $versionInput"
              } else {
                $versionInput = "v1.0.0"
                Write-Host "No existing versions found, starting with: $versionInput"
              }
            }

            $versionJson = ./scripts/release/version.ps1 -Version $versionInput -AsJson
            Write-DebugBlock -Title 'versionJson' -Value $versionJson

            if ([string]::IsNullOrWhiteSpace($versionJson)) {
              Emit-StepError -Message 'version.ps1 returned empty output.'
            }

            $versionInfo = $versionJson | ConvertFrom-Json -Depth 6

            if ($versionInfo.Latest -and -not $versionInfo.IsGreaterThanLatest) {
              $latest = $versionInfo.Latest.Normalized
              Emit-StepError -Message "Proposed version $($versionInfo.Candidate.Normalized) must be greater than latest $latest."
            }

            $workspace = Get-Location
            $artifactDir = Join-Path $workspace 'artifacts/workflow'
            [System.IO.Directory]::CreateDirectory($artifactDir) | Out-Null

            $versionFile = Join-Path $artifactDir 'version.json'
            $versionJson | Out-File -FilePath $versionFile -Encoding utf8

            Set-ActionOutput -Name 'normalized_version' -Value $versionInfo.Candidate.Normalized
            Set-ActionOutput -Name 'tag_name' -Value $versionInfo.Candidate.TagName
            Set-ActionOutput -Name 'version_info_path' -Value ((Resolve-Path -LiteralPath $versionFile).Path)

            if ($versionInfo.Latest) {
              Set-ActionOutput -Name 'latest_version' -Value $versionInfo.Latest.Normalized
            } else {
              Set-ActionOutput -Name 'latest_version' -Value ''
            }

            $tagExists = ($versionInfo.TagExists -eq $true)
            Set-ActionOutput -Name 'tag_exists' -Value ($tagExists.ToString().ToLowerInvariant())
          }
          catch {
            Emit-StepError -Message 'Resolve release version step failed.' -ErrorRecord $_
          }
          finally {
            Write-Host "::notice::ResolveVersion.Success=$?"
            Write-Host "::notice::ResolveVersion.LastExit=$LASTEXITCODE"

            if ($Error.Count -gt 0) {
              Write-Host "::warning::ResolveVersion.ErrorQueueCount=$($Error.Count)"
              $Error | ForEach-Object {
                $record = ($_ | Format-List * -Force | Out-String).Trim()
                if (-not [string]::IsNullOrWhiteSpace($record)) {
                  $record.Split([Environment]::NewLine) | ForEach-Object {
                    if (-not [string]::IsNullOrWhiteSpace($_)) {
                      Write-Host "::warning::ResolveVersion.ErrorRecord=$_"
                    }
                  }
                }
              }
            }
          }

      - name: Enumerate overlay payload
        id: overlay
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          $artifactDir = Join-Path (Get-Location) 'artifacts/workflow'
          [System.IO.Directory]::CreateDirectory($artifactDir) | Out-Null

          $overlayJson = ./scripts/release/overlay.ps1 -AsJson
          $overlay = $overlayJson | ConvertFrom-Json -Depth 6

          $overlayFile = Join-Path $artifactDir 'overlay.json'
          $overlayJson | Out-File -FilePath $overlayFile -Encoding utf8

          Set-ActionOutput -Name 'overlay_payload_path' -Value ((Resolve-Path -LiteralPath $overlayFile).Path)
          Set-ActionOutput -Name 'overlay_file_count' -Value ([string]$overlay.FileCount)
          Set-ActionOutput -Name 'overlay_total_bytes' -Value ([string]$overlay.ByteSizeTotal)

      - name: Generate hash manifest
        id: manifest
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          $artifactDir = Join-Path (Get-Location) 'artifacts/workflow'
          [System.IO.Directory]::CreateDirectory($artifactDir) | Out-Null
          $manifestPath = Join-Path $artifactDir 'manifest.sha256.txt'

          $manifestJson = ./scripts/release/hash-manifest.ps1 -OutputPath $manifestPath -AsJson
          $manifestInfo = $manifestJson | ConvertFrom-Json -Depth 6

          $manifestInfoFile = Join-Path $artifactDir 'manifest.json'
          $manifestJson | Out-File -FilePath $manifestInfoFile -Encoding utf8

          Set-ActionOutput -Name 'manifest_path' -Value ((Resolve-Path -LiteralPath $manifestPath).Path)
          Set-ActionOutput -Name 'manifest_info_path' -Value ((Resolve-Path -LiteralPath $manifestInfoFile).Path)
          Set-ActionOutput -Name 'manifest_root_hash' -Value $manifestInfo.RootHash
          Set-ActionOutput -Name 'manifest_file_count' -Value ([string]$manifestInfo.FileCount)

      - name: Verify manifest reproducibility
        id: manifest_verify
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $expectedRootHash = '${{ steps.manifest.outputs.manifest_root_hash }}'
          if ([string]::IsNullOrWhiteSpace($expectedRootHash)) {
            throw 'Manifest root hash output missing from primary manifest step.'
          }

          $artifactDir = Join-Path (Get-Location) 'artifacts/workflow'
          [System.IO.Directory]::CreateDirectory($artifactDir) | Out-Null
          $recheckPath = Join-Path $artifactDir 'manifest.recheck.sha256.txt'

          $recomputedJson = ./scripts/release/hash-manifest.ps1 -OutputPath $recheckPath -AsJson
          $recomputed = $recomputedJson | ConvertFrom-Json -Depth 6

          $expectedCountRaw = '${{ steps.manifest.outputs.manifest_file_count }}'
          if (-not [string]::IsNullOrWhiteSpace($expectedCountRaw)) {
            $expectedCount = [int]$expectedCountRaw
            if ($recomputed.FileCount -ne $expectedCount) {
              throw "Recomputed manifest file count $($recomputed.FileCount) does not match expected $expectedCount."
            }
          }

          if ($recomputed.RootHash -ne $expectedRootHash) {
            throw "Recomputed root hash $($recomputed.RootHash) does not match expected $expectedRootHash."
          }

          Write-Host 'Root hash reproducibility validated.'

      - name: Compute diff summary
        id: diff
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          $artifactDir = Join-Path (Get-Location) 'artifacts/workflow'
          [System.IO.Directory]::CreateDirectory($artifactDir) | Out-Null

          $version = '${{ steps.version.outputs.normalized_version }}'
          $diffJson = ./scripts/release/diff-summary.ps1 -Version $version -AsJson
          $diffInfo = $diffJson | ConvertFrom-Json -Depth 6

          $diffFile = Join-Path $artifactDir 'diff-summary.json'
          $diffJson | Out-File -FilePath $diffFile -Encoding utf8

          Set-ActionOutput -Name 'diff_summary_path' -Value ((Resolve-Path -LiteralPath $diffFile).Path)
          Set-ActionOutput -Name 'current_commit' -Value $diffInfo.CurrentCommit
          Set-ActionOutput -Name 'previous_version' -Value ($diffInfo.PreviousVersion ?? '')
          $isInitial = [bool]$diffInfo.IsInitialRelease
          Set-ActionOutput -Name 'is_initial_release' -Value ($isInitial.ToString().ToLowerInvariant())

      - name: Create annotated release tag
        id: create_tag
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $tagName = '${{ steps.version.outputs.tag_name }}'
          if ([string]::IsNullOrWhiteSpace($tagName)) {
            throw 'Tag name not resolved.'
          }

          $tagExists = [System.Convert]::ToBoolean('${{ steps.version.outputs.tag_exists }}')
          if ($tagExists) {
            throw "Tag $tagName already exists. Aborting release."
          }

          git config user.name '${{ github.actor }}'
          git config user.email '${{ github.actor }}@users.noreply.github.com'

          $message = "Overlay release $tagName (triggered by $env:GITHUB_ACTOR)"
          git tag -a $tagName -m $message
          git push origin $tagName

      - name: Package overlay artifact and draft release
        id: package
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          $artifactDir = Join-Path (Get-Location) 'artifacts/workflow'
          [System.IO.Directory]::CreateDirectory($artifactDir) | Out-Null

          $overlay = Get-Content -LiteralPath '${{ steps.overlay.outputs.overlay_payload_path }}' -Raw | ConvertFrom-Json -Depth 6
          $manifest = Get-Content -LiteralPath '${{ steps.manifest.outputs.manifest_info_path }}' -Raw | ConvertFrom-Json -Depth 6

          $artifactJson = ./scripts/release/release-artifact.ps1 `
            -Version '${{ steps.version.outputs.normalized_version }}' `
            -OverlayPayload $overlay `
            -Manifest $manifest `
            -AsJson

          $artifactInfo = $artifactJson | ConvertFrom-Json -Depth 6
          $artifactInfoFile = Join-Path $artifactDir 'artifact.json'
          $artifactJson | Out-File -FilePath $artifactInfoFile -Encoding utf8

          $artifactPath = (Resolve-Path -LiteralPath $artifactInfo.OutputPath).Path
          Set-ActionOutput -Name 'artifact_path' -Value $artifactPath
          Set-ActionOutput -Name 'artifact_name' -Value $artifactInfo.FileName
          Set-ActionOutput -Name 'artifact_sha256' -Value $artifactInfo.Sha256
          Set-ActionOutput -Name 'artifact_info_path' -Value ((Resolve-Path -LiteralPath $artifactInfoFile).Path)

          $draftNotesPath = Join-Path $artifactDir 'release-notes-draft.md'
          'Release notes will be attached in a subsequent step.' | Out-File -FilePath $draftNotesPath -Encoding utf8

          $tagName = '${{ steps.version.outputs.tag_name }}'
          $normalizedVersion = '${{ steps.version.outputs.normalized_version }}'
          $releaseTitle = "Overlay release $normalizedVersion"
          $targetCommit = '${{ steps.diff.outputs.current_commit }}'

          $existingRelease = & gh release view $tagName --json tagName --jq '.tagName' 2>$null
          if ($LASTEXITCODE -eq 0 -and -not [string]::IsNullOrWhiteSpace($existingRelease)) {
            throw "Release $tagName already exists."
          }

          $releaseArgs = @(
            'release','create',$tagName,$artifactPath,
            '--title',$releaseTitle,
            '--notes-file',$draftNotesPath,
            '--draft',
            '--target',$targetCommit
          )
          & gh @releaseArgs

          $releaseDataJson = gh release view $tagName --json url,isDraft
          $releaseData = $releaseDataJson | ConvertFrom-Json -Depth 4
          Set-ActionOutput -Name 'release_url' -Value $releaseData.url

      - name: Verify artifact overlay isolation
        id: artifact_isolation
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $artifactPath = '${{ steps.package.outputs.artifact_path }}'
          if ([string]::IsNullOrWhiteSpace($artifactPath)) {
            throw 'Artifact path output missing from packaging step.'
          }

          if (-not (Test-Path -LiteralPath $artifactPath)) {
            throw "Artifact path $artifactPath not found."
          }

          Add-Type -AssemblyName System.IO.Compression.FileSystem

          $archive = [System.IO.Compression.ZipFile]::OpenRead($artifactPath)
          try {
            $invalidEntries = @()
            foreach ($entry in $archive.Entries) {
              $name = $entry.FullName.Replace('\', '/')
              if ([string]::IsNullOrWhiteSpace($name)) {
                continue
              }

              if ($name.EndsWith('/')) {
                continue
              }

              if ($name -eq 'manifest.sha256.txt') {
                continue
              }

              if (-not $name.StartsWith('overlay/')) {
                $invalidEntries += $name
              }
            }

            if ($invalidEntries.Count -gt 0) {
              throw "Artifact contains non-overlay entries: $($invalidEntries -join ', ')"
            }
          }
          finally {
            $archive.Dispose()
          }

          Write-Host 'Artifact overlay isolation verified.'

      - name: Publish release notes and finalize
        id: publish
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          $artifactDir = Join-Path (Get-Location) 'artifacts/workflow'
          [System.IO.Directory]::CreateDirectory($artifactDir) | Out-Null

          $overlay = Get-Content -LiteralPath '${{ steps.overlay.outputs.overlay_payload_path }}' -Raw | ConvertFrom-Json -Depth 6
          $manifest = Get-Content -LiteralPath '${{ steps.manifest.outputs.manifest_info_path }}' -Raw | ConvertFrom-Json -Depth 6
          $diff = Get-Content -LiteralPath '${{ steps.diff.outputs.diff_summary_path }}' -Raw | ConvertFrom-Json -Depth 6

          $releaseDateUtc = (Get-Date).ToUniversalTime()

          $notesJson = ./scripts/release/release-notes.ps1 `
            -Version '${{ steps.version.outputs.normalized_version }}' `
            -MaintainerSummary $env:MAINTAINER_SUMMARY `
            -OverlayPayload $overlay `
            -Manifest $manifest `
            -Diff $diff `
            -CurrentCommit '${{ steps.diff.outputs.current_commit }}' `
            -ReleaseDateUtc $releaseDateUtc `
            -AsJson

          $notes = $notesJson | ConvertFrom-Json -Depth 6

          $notesPath = Join-Path $artifactDir 'release-notes.md'
          $notes.BodyMarkdown | Out-File -FilePath $notesPath -Encoding utf8

          $metadataPath = Join-Path $artifactDir 'release-metadata.json'
          $notes.MetadataJson | Out-File -FilePath $metadataPath -Encoding utf8

          Set-ActionOutput -Name 'release_notes_path' -Value ((Resolve-Path -LiteralPath $notesPath).Path)
          Set-ActionOutput -Name 'metadata_path' -Value ((Resolve-Path -LiteralPath $metadataPath).Path)

          $tagName = '${{ steps.version.outputs.tag_name }}'
          gh release edit $tagName --notes-file $notesPath --draft=false

      - name: Verify published release
        id: verify
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $tagName = '${{ steps.version.outputs.tag_name }}'
          $releaseJson = gh release view $tagName --json assets,body,isDraft
          $release = $releaseJson | ConvertFrom-Json -Depth 6

          if ($release.isDraft) {
            throw "Release $tagName remains in draft state."
          }

          $assets = @($release.assets)
          if ($assets.Count -ne 1) {
            throw "Expected a single release asset, found $($assets.Count)."
          }

          $asset = $assets[0]
          $expectedAsset = '${{ steps.package.outputs.artifact_name }}'
          if ($asset.name -ne $expectedAsset) {
            throw "Release asset name '$($asset.name)' does not match expected '$expectedAsset'."
          }

          $metadataJson = Get-Content -LiteralPath '${{ steps.publish.outputs.metadata_path }}' -Raw
          $escaped = [regex]::Escape($metadataJson.Trim())
          if (-not [regex]::IsMatch($release.body, $escaped)) {
            throw 'Release notes metadata block not found in published body.'
          }

          Write-Host 'Release published with expected asset and metadata.'

      - name: Report workflow duration
        id: timing_complete
        if: always()
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Set-ActionOutput {
            param(
              [Parameter(Mandatory = $true)][string]$Name,
              [string]$Value
            )

            if ($null -eq $Value) {
              $Value = ''
            }

            "$Name=$Value" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          $startIso = '${{ steps.timing_start.outputs.started_at_iso }}'
          $startMsRaw = '${{ steps.timing_start.outputs.started_at_ms }}'

          if ([string]::IsNullOrWhiteSpace($startMsRaw)) {
            Write-Warning 'Timing start output missing; skipping duration calculation.'
            return
          }

          $startMs = [int64]$startMsRaw
          $startValue = [System.DateTimeOffset]::FromUnixTimeMilliseconds($startMs)
          if (-not [string]::IsNullOrWhiteSpace($startIso)) {
            $parsed = [System.DateTimeOffset]::MinValue
            if ([System.DateTimeOffset]::TryParse($startIso, [System.Globalization.CultureInfo]::InvariantCulture, [System.Globalization.DateTimeStyles]::RoundtripKind, [ref]$parsed)) {
              $startValue = $parsed
            }
          }

          $now = [System.DateTimeOffset]::UtcNow
          $durationMs = $now.ToUnixTimeMilliseconds() - $startMs
          if ($durationMs -lt 0) {
            $durationMs = 0
          }

          $durationSeconds = [Math]::Round($durationMs / 1000, 2)

          Set-ActionOutput -Name 'ended_at_iso' -Value $now.ToString('o')
          Set-ActionOutput -Name 'duration_ms' -Value ([string]$durationMs)
          Set-ActionOutput -Name 'duration_seconds' -Value ([string]$durationSeconds)

          Write-Host "::notice::Overlay release duration: $durationSeconds seconds (started $($startValue.ToString('o')), ended $($now.ToString('o')))."
